#!/usr/local/bin/zsh
autoload -U colors && colors
autoload -Uz add-zsh-hook
autoload -Uz zsh/zle
autoload -Uz vcs_info


prompt_j2_setup() {

  prompt_opts=( subst
                percent
                bang )

  init_globals

  #Hooks
      # shows symbol base on exit status for limited period of time
                                        # reverting to a default delimiter after

  add-zsh-hook precmd vcs_cfg
  add-zsh-hook precmd compose_vcs
  add-zsh-hook precmd  dyn_exit
  add-zsh-hook precmd compose_ps1
  add-zsh-hook precmd compose_rps1


}

init_globals() {

  # utility

  PRMPT_NEWLIN=$'\r%{\n%}%{\r%}'

  #The symbols surrounding your username
  NAME_OUTR_LEFT="["
  NAME_OUTR_RIGHT="]"
  NAME_OUTR_COLOR=yellow # the symbol color

  # symbols for adaptive delimiter
  DEF_OUT="‣"    # default symbol delimiting prompt from command
  SUCC_OUT="✓"   # symbol to be temporarily shown after a command exits with status 0
  FAIL_OUT="x"   # symbol to be temporarily shown after a command exits with status 1
  STAT_IND_LEN=2 # length of time in seconds to show status symbol after command completion

  # directory context info
  DIR_NAME="$(basename `pwd`)/"

  # directory context styling
  DIR_SYM=▪      # symbol next to directory name
  DCOLOR=blue    # color of symbol next to dir

  # branch context styling
  BRANCH_SYM=▪   # symbol next to git branch name
  BCOLOR=green   # color of symbol next to branch name

}


# TODO impl git
vcs_cfg() {
    vcs_info
    zstyle ':vcs_info:*' enable git
    zstyle ':vcs_info:git:*' formats '[%b]'
}

compose_vcs() {
  local branch_name=${vcs_info_msg_0_}
  local BSYMBOL=$fg[${DCOLOR}]$BRANCH_SYM$reset_color

  let bsym_len="$#BSYMBOL / 4"

  let BOUT_LEN="$(echo $#branch_name) + $#bsym_len - 4"
  BOUT="${BSYMBOL} ${branch_name}"
}

compose_ps1() {
  local ptr_succ="%{$fg[green]%}${SUCC_OUT}%{$reset_color%}"
  local ptr_fail="%{$fg[red]%}${FAIL_OUT}%{$reset_color%}"
  local name_sec="%B%{$fg[$NAME_OUTR_COLOR]%}$NAME_OUTR_LEFT%{$reset_color%}%b%n%B%{$fg[$NAME_OUTR_COLOR]%}$NAME_OUTR_RIGHT%{$reset_color%}%b"

  len=$BOUT_LEN

  if [[ $len -gt 0 ]]; then

    ((  left_padding =  $COLUMNS - len - 5 ))

        PS1="${(l:${left_padding}:: ::$BOUT:)}${PRMPT_NEWLIN}${name_sec} %(?.$ptr_succ.$ptr_fail) "

  else
        PS1="${name_sec} %(?.$ptr_succ.$ptr_fail) "
  fi

}

compose_rps1() {
  local dsymbol=%{$fg[$DCOLOR]%}$DIR_SYM%{$reset_color%}
  RPS1="$dsymbol $DIR_NAME"
}

# Kill any scheduled events that have not been executed before a new command is entered
# TODO remove dependency on sched,
# use zsh async lib potentially
kill_outstanding_scheds() {
  for ((i = 1; i <= $#zsh_scheduled_events; i++)); do
    sched -$i
  done
}

# Overrides default prompt enter key functionality
# allows for logic before and after passing a command
# to zsh
# Called whenever enter is pressed
hook-accept-line() {

  kill_outstanding_scheds

  PS1="$DEF_OUT "
  RPS1="-"
  zle reset-prompt
  zle accept-line

}
zle -N hook-accept-line
bindkey "^M" hook-accept-line


dyn_exit(){
	sched +$STAT_IND_LEN delim_reset
}

delim_reset(){
  local name_sec="%B%{$fg[$NAME_OUTR_COLOR]%}$NAME_OUTR_LEFT%{$reset_color%}%b%n%B%{$fg[$NAME_OUTR_COLOR]%}$NAME_OUTR_RIGHT%{$reset_color%}%b"

len=$BOUT_LEN

  if [[ $len -gt 0 ]]; then

    ((  left_padding =  $COLUMNS - len - 5 ))


        PS1="${(l:${left_padding}:: ::$BOUT:)}${PRMPT_NEWLIN}${name_sec} ${DEF_OUT} "

  else
        PS1="${name_sec} ${DEF_OUT} "
  fi

  zle && zle reset-prompt

}



