#!/usr/local/bin/zsh

prompt_j2_setup() {

  prompt_opts=( subst
                percent
                bang )

  init_globals
  init_async

  add-zsh-hook precmd dir_cfg
  add-zsh-hook precmd vcs_cfg
  add-zsh-hook precmd compose_vcs

  add-zsh-hook precmd kill_outstanding_scheds
  add-zsh-hook precmd dyn_exit
  add-zsh-hook preexec kill_outstanding_scheds

  add-zsh-hook precmd comp_prompt_variants
  add-zsh-hook precmd compose_ps1
  add-zsh-hook precmd compose_rps1

  add-zsh-hook precmd show_cursor

  prompt_cleanup cleanup

}

dir_cfg() {
  # directory context info
  DIR_NAME=${$( basename $(pwd))}
}

set_stat_time() {
  local cur_time='[%D{%L:%M:%S %p}]'
#  PS1="${NAME_SEC} $cur_time ${DEF_OUT} "
  PS1="${NAME_SEC} $cur_time "
}

set_stat_spinner() {

    local spinner=("üïõ"
                   "üïê"
                   "üïë"
                   "üïí"
                   "üïì"
                   "üïî"
                   "üïï"
                   "üïñ"
                   "üïó"
                   "üïò"
                   "üïô"
                   "üïö" )
   let "spin_index = ($IDLE_CTR % $#spinner) + 1"
   let "midpoint = $COLUMNS / 2 + 34"

   if [[ $TTYIDLE -lt 60 ]]; then
     local away_time=$TTYIDLE
     local away_time="$away_time sec"
   elif [[ $TTYIDLE -lt 3600 ]]; then
     let "away_time = $TTYIDLE / 60"
     local away_time="$away_time min"
   else
     let "away_time = $TTYIDLE / 3600"
     local away_time="$away_time hours"
   fi

   local mid_clock=${(l:${midpoint}:: ::${spinner[$spin_index]} idle ${away_time}  :)}
   print -PN "\r${mid_clock}"
   hide_cursor
   let "IDLE_CTR = $IDLE_CTR + 1"
}

show_cursor(){
   print -PN "\e[?25h"
}

hide_cursor(){
   print -PN "\e[?25l"
}

init_async() {
   IDLE_CTR=0

   async_start_worker time_updater -n

    callback() {
      if [[ "$TTYIDLE" -gt  "1800" ]]; then
        set_stat_spinner
        async_job time_updater sleep .5
      else
         async_job time_updater sleep 3
      fi
    }

  async_register_callback time_updater callback

  async_job  time_updater sleep 1
}

init_globals() {

  #The symbols surrounding your username
  NAME_OUTR_LEFT="["
  NAME_OUTR_RIGHT="]"
  NAME_OUTR_COLOR=green # the symbol color

  # symbols for adaptive delimiter
  DEF_OUT="‚Ä£"    # default symbol delimiting prompt from command
  SUCC_OUT="‚úì"   # symbol to be temporarily shown after a command exits with status 0
  FAIL_OUT="x"   # symbol to be temporarily shown after a command exits with status 1
  STAT_IND_LEN=2 # length of time in seconds to show status symbol after command completion

  # directory context styling
  DIR_SYM="‚ñ™ "      # symbol next to directory name
  DCOLOR=cyan    # color of symbol next to dir

  # branch context styling
  BRANCH_SYM=‚éá   # symbol next to git branch name
  BCOLOR=green   # color of symbol next to branch name

  #pastcmd color
  PAST_CMD_COLOR=yellow; # The color that past entered cmds will show as
}

vcs_cfg() {
    vcs_info
    zstyle ':vcs_info:*' enable git
    zstyle ':vcs_info:git:*' formats '[%b]'
}

compose_vcs() {
  local branch_name=${vcs_info_msg_0_}
  local BSYMBOL="%{$fg[green]%}${BRANCH_SYM}%{$reset_color%}"

  let bsym_len="$#BSYMBOL / 4"

  let BOUT_LEN="$(echo $#branch_name) + $#bsym_len - 4"
  BOUT="${BSYMBOL} ${branch_name}"
  
  len=$BOUT_LEN
  ((  left_padding_len =  $COLUMNS - len - 1 ))
  LEFT_PADDING=${(l:${left_padding_len}:: ::$BOUT:)}
}


comp_prompt_variants() {

  PTR_SUCC="%{$fg[green]%}${SUCC_OUT}%{$reset_color%}"
  PTR_FAIL="%{$fg[red]%}${FAIL_OUT}%{$reset_color%}"
  NAME_SEC="%B%{$fg[$NAME_OUTR_COLOR]%}$NAME_OUTR_LEFT%{$reset_color%}%b%n%B%{$fg[$NAME_OUTR_COLOR]%}$NAME_OUTR_RIGHT%{$reset_color%}%b"
  
}

set_dyn() {
  PS1="${NAME_SEC} %(?.$PTR_SUCC.$PTR_FAIL) "   
}

set_2ldyn() {
  
  PS1="${LEFT_PADDING}
${NAME_SEC} %(?.$PTR_SUCC.$PTR_FAIL) "

}

set_stat() {
  PS1="${NAME_SEC} ${DEF_OUT} "
}

set_2lstat(){
        PS1="${LEFT_PADDING}
${NAME_SEC} ${DEF_OUT} "
}

set_minimal() {
  PS1="$DEF_OUT "
  RPS1="-"

}

compose_ps1() {

  len=$BOUT_LEN

  if [[ $len -gt 0 ]]; then
	set_2ldyn
  else
	set_dyn
  fi

}

compose_rps1() {
  local dsymbol=%{$fg[$DCOLOR]%}$DIR_SYM%{$reset_color%}
  RPS1="${dsymbol}${DIR_NAME}"
}

# Kill any scheduled events that have not been executed before a new command is entered
# TODO remove dependency on sched,
# use zsh async lib potentially
kill_outstanding_scheds() {
  for ((i = 1; i <= $#zsh_scheduled_events; i++)); do
    sched -$i
  done
}

# Overrides default prompt enter key functionality
# allows for logic before and after passing a command
# to zsh
# Called whenever enter is pressed
hook-accept-line() {

  set_minimal

  local init_buffer=${fg[$PAST_CMD_COLOR]}${BUFFER}${reset_color}
  # local init_buffer=$BUFFER

  zle reset-prompt
  
  zle accept-line
   print -PN "\r${PS1}${init_buffer}"

}
zle -N hook-accept-line
bindkey "^M" hook-accept-line

dyn_exit(){
	sched +$STAT_IND_LEN delim_reset
}

delim_reset(){

  if [[ $len -gt 0 ]]; then
        set_2lstat
  else
	set_stat
  fi

  zle && zle reset-prompt
}

cleanup() {
  zle && 
  bindkey "^M" .accept-line
}
zle -N cleanup

