#!/usr/local/bin/zsh

prompt_j2_setup() {

  prompt_opts=( subst
                percent
                bang )

  init_globals

  add-zsh-hook precmd vcs_cfg
  add-zsh-hook precmd compose_vcs
  add-zsh-hook precmd  dyn_exit

  add-zsh-hook precmd comp_prompt_variants
  add-zsh-hook precmd compose_ps1
  add-zsh-hook precmd compose_rps1

}

init_globals() {

  # utility

  PRMPT_NEWLIN=$'\r%{\n%}%{\r%}'

  #The symbols surrounding your username
  NAME_OUTR_LEFT="["
  NAME_OUTR_RIGHT="]"
  NAME_OUTR_COLOR=yellow # the symbol color

  # symbols for adaptive delimiter
  DEF_OUT="‣"    # default symbol delimiting prompt from command
  SUCC_OUT="✓"   # symbol to be temporarily shown after a command exits with status 0
  FAIL_OUT="x"   # symbol to be temporarily shown after a command exits with status 1
  STAT_IND_LEN=2 # length of time in seconds to show status symbol after command completion

  # directory context info
  DIR_NAME="$(basename `pwd`)/"

  # directory context styling
  DIR_SYM="▪ "      # symbol next to directory name
  DCOLOR=blue    # color of symbol next to dir

  # branch context styling
  BRANCH_SYM=⎇   # symbol next to git branch name
  BCOLOR=green   # color of symbol next to branch name

}

# TODO impl git
vcs_cfg() {
    vcs_info
    zstyle ':vcs_info:*' enable git
    zstyle ':vcs_info:git:*' formats '[%b]'
}

compose_vcs() {
  local branch_name=${vcs_info_msg_0_}
 #local BSYMBOL=$fg[${DCOLOR}]${BRANCH_SYM}${reset_color}

  local BSYMBOL="%{$fg[green]%}${BRANCH_SYM}%{$reset_color%}"

  let bsym_len="$#BSYMBOL / 4"

  let BOUT_LEN="$(echo $#branch_name) + $#bsym_len - 4"
 BOUT="${BSYMBOL} ${branch_name}"
 # BOUT="${branch_name}"
  
  len=$BOUT_LEN
  ((  left_padding_len =  $COLUMNS - len - 1 ))
  LEFT_PADDING=${(l:${left_padding_len}:: ::$BOUT:)}
}


comp_prompt_variants() {

  PTR_SUCC="%{$fg[green]%}${SUCC_OUT}%{$reset_color%}"
  PTR_FAIL="%{$fg[red]%}${FAIL_OUT}%{$reset_color%}"
  NAME_SEC="%B%{$fg[$NAME_OUTR_COLOR]%}$NAME_OUTR_LEFT%{$reset_color%}%b%n%B%{$fg[$NAME_OUTR_COLOR]%}$NAME_OUTR_RIGHT%{$reset_color%}%b"
  
}

set_dyn() {
  PS1="${NAME_SEC} %(?.$PTR_SUCC.$PTR_FAIL) "   
}

set_2ldyn() {
  
  PS1="${LEFT_PADDING}
${NAME_SEC} %(?.$PTR_SUCC.$PTR_FAIL) "

}

set_stat() {
  PS1="${NAME_SEC} ${DEF_OUT} "
}

set_2lstat(){
        PS1="${LEFT_PADDING}
${NAME_SEC} ${DEF_OUT} "
}

set_minimal() {
  PS1="$DEF_OUT "
  RPS1="-"
}

compose_ps1() {

  len=$BOUT_LEN

  if [[ $len -gt 0 ]]; then
	set_2ldyn
  else
	set_dyn
  fi

}

compose_rps1() {
  local dsymbol=%{$fg[$DCOLOR]%}$DIR_SYM%{$reset_color%}
  RPS1="${dsymbol}${DIR_NAME}"
}

# Kill any scheduled events that have not been executed before a new command is entered
# TODO remove dependency on sched,
# use zsh async lib potentially
kill_outstanding_scheds() {
  for ((i = 1; i <= $#zsh_scheduled_events; i++)); do
    sched -$i
  done
}

# Overrides default prompt enter key functionality
# allows for logic before and after passing a command
# to zsh
# Called whenever enter is pressed
hook-accept-line() {

  kill_outstanding_scheds
  
  set_minimal

  zle reset-prompt
  zle accept-line

}
zle -N hook-accept-line
bindkey "^M" hook-accept-line

dyn_exit(){
	sched +$STAT_IND_LEN delim_reset
}

delim_reset(){

  if [[ $len -gt 0 ]]; then
        set_2lstat
  else
	set_stat
  fi

  zle && zle reset-prompt
}



