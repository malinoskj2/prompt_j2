#!/usr/local/bin/zsh

prompt_j2_setup() {

  prompt_opts=( subst
                percent
                bang )

  init_globals
  init_async

  add-zsh-hook precmd dir_cfg
  add-zsh-hook precmd vcs_cfg
  add-zsh-hook precmd compose_vcs

  add-zsh-hook precmd kill_outstanding_scheds
  add-zsh-hook precmd sched_dyn_exit
  add-zsh-hook precmd sched_idle_func
  add-zsh-hook preexec kill_outstanding_scheds

  add-zsh-hook precmd comp_prompt_variants
  add-zsh-hook precmd compose_ps1
  add-zsh-hook precmd compose_rps1

  add-zsh-hook precmd show_cursor

  prompt_cleanup cleanup

}

dir_cfg() {
  # directory context info
  DIR_NAME=${$( basename $(pwd))}
}

set_stat_time() {
  local cur_time='[%D{%L:%M:%S %p}]'
#  PS1="${NAME_SEC} $cur_time ${DEF_OUT} "
  PS1="${NAME_SEC} $cur_time "
}

show_cursor(){
   print -PN "\e[?25h"
}

hide_cursor(){
   print -PN "\e[?25l"
}

init_async() {

}

init_globals() {

  #The symbols surrounding your username
  NAME_OUTR_LEFT="("
  NAME_OUTR_RIGHT=")"
  NAME_OUTR_COLOR=magenta # the symbol color

  # symbols for adaptive delimiter
  DEF_OUT="‣"    # default symbol delimiting prompt from command
  SUCC_OUT="✓"   # symbol to be temporarily shown after a command exits with status 0
  FAIL_OUT="x"   # symbol to be temporarily shown after a command exits with status 1
  STAT_IND_LEN=2 # length of time in seconds to show status symbol after command completion
  
  # idle_func and trigger time
  IDLE_FUNC=exit
  IDLE_FUNC_TIMER=3600 # Seconds


  # directory context styling
  DIR_SYM="▪ "      # symbol next to directory name
  DCOLOR=cyan    # color of symbol next to dir

  # branch context styling
  BRANCH_SYM=⎇   # symbol next to git branch name
  BCOLOR=green   # color of symbol next to branch name

  #pastcmd color
  PAST_CMD_COLOR=magenta; # The color that past entered cmds will show as
}

vcs_cfg() {
    vcs_info
    zstyle ':vcs_info:*' enable git
    zstyle ':vcs_info:git:*' formats '[%b]'
}

compose_vcs() {
  local branch_name=${vcs_info_msg_0_}
  local BSYMBOL="%{$fg[green]%}${BRANCH_SYM}%{$reset_color%}"

  let bsym_len="$#BSYMBOL / 4"

  let BOUT_LEN="$(echo $#branch_name) + $#bsym_len - 4"
  BOUT="${BSYMBOL} ${branch_name}"
  
  len=$BOUT_LEN
  ((  left_padding_len =  $COLUMNS - len - 1 ))
  LEFT_PADDING=${(l:${left_padding_len}:: ::$BOUT:)}
}


comp_prompt_variants() {

  PTR_SUCC="%{$fg[green]%}${SUCC_OUT}%{$reset_color%}"
  PTR_FAIL="%{$fg[red]%}${FAIL_OUT}%{$reset_color%}"
  NAME_SEC="%B%{$fg[$NAME_OUTR_COLOR]%}$NAME_OUTR_LEFT%{$reset_color%}%b%n%B%{$fg[$NAME_OUTR_COLOR]%}$NAME_OUTR_RIGHT%{$reset_color%}%b"
  
}

set_dyn() {
  PS1="${NAME_SEC} %(?.$PTR_SUCC.$PTR_FAIL) "   
}

set_2ldyn() {
  
  PS1="${LEFT_PADDING}
${NAME_SEC} %(?.$PTR_SUCC.$PTR_FAIL) "

}

set_stat() {
  PS1="${NAME_SEC} ${DEF_OUT} "
}

set_2lstat(){
        PS1="${LEFT_PADDING}
${NAME_SEC} ${DEF_OUT} "
}

set_minimal() {
  PS1="$DEF_OUT "
  RPS1="-"

}

compose_ps1() {

  len=$BOUT_LEN

  if [[ $len -gt 0 ]]; then
	set_2ldyn
  else
	set_dyn
  fi

}

compose_rps1() {
  local dsymbol=%{$fg[$DCOLOR]%}$DIR_SYM%{$reset_color%}
  RPS1="${dsymbol}${DIR_NAME}"
}

# Kill any scheduled events that have not been executed before a new command is entered
# TODO remove dependency on sched,
# use zsh async lib potentially
kill_outstanding_scheds() {
  for ((i = 1; i <= $#zsh_scheduled_events; i++)); do
    sched -$i
  done
}

# Overrides default prompt enter key functionality
# allows for logic before and after passing a command
# to zsh
# Called whenever enter is pressed
hook-accept-line() {

  set_minimal

  local init_buffer=${fg[$PAST_CMD_COLOR]}${BUFFER}${reset_color}
  # local init_buffer=$BUFFER

  zle reset-prompt
  
  zle accept-line
   print -PN "\r${PS1}${init_buffer}"

}
zle -N hook-accept-line
bindkey "^M" hook-accept-line

sched_dyn_exit(){
	sched +$STAT_IND_LEN delim_reset
}

delim_reset(){

  if [[ $len -gt 0 ]]; then
        set_2lstat
  else
	set_stat
  fi

  zle && zle reset-prompt
}

sched_idle_func() {

       sched +$IDLE_FUNC_TIMER $IDLE_FUNC
}


cleanup() {
  zle && 
  bindkey "^M" .accept-line
}
zle -N cleanup

